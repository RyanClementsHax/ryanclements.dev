# Sanitizing Posts <!-- omit in toc -->

- [Context and Problem Statement](#context-and-problem-statement)
- [Considered Options](#considered-options)
- [Decision Outcome](#decision-outcome)
- [Options](#options)
  - [Sanitize the html](#sanitize-the-html)
  - [Do not sanitize the html](#do-not-sanitize-the-html)

## Context and Problem Statement

Sanitizing html is important as to avoid security vulnerabilities. The main use case for doing this arrises when a web page displays content generated by parties not in your control. If that party is malicious, they could inject malicious content into your webpage. The consequences for this are large when the webpage has access to sensitive information or escalated capabilities.

I generate dynamic html when rendering posts from markdown stored by me in this repo and protect no sensitive content. No other sources are used to create the dynamic html thus avoiding the main use case for sanitizing html which is sanitizing potentially malicious user generated content. The main risk for me is if someone injects content defaming my public image.

Should I still sanitize the html generated when rendering posts?

## Considered Options

- Sanitize the html
- Do not sanitize the html

## Decision Outcome

Decision: Don't sanitize the html

Why: Because I'm not at significant enough risk when the content needing sanitzation is created by me in this repo, but I should consider sanitization in the future if the content isn't generated by me or lives in something else like a database as that could be compromised.

## Options

### Sanitize the html

The sanitization would happen most easily with [rehype-sanitize](https://github.com/rehypejs/rehype-sanitize). The content pipeline would look something like the following.

```ts
import { unified, Plugin } from 'unified'
import { Schema } from 'hast-util-sanitize'
import deepmerge from '@fastify/deepmerge'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeSanitize, { defaultSchema } from 'rehype-sanitize'

// other plugins omitted for brevity
const contentProcessor = unified()
  .use(remarkParse)
  .use(remarkRehype, { allowDangerousHtml: true })
  .use(
    rehypeSanitize,
    deepmerge()<Schema, Schema>(defaultSchema, {
      tagNames: ['aside'],
      attributes: { '*': ['className'], img: ['data-blurdataurl'] }
    })
  )
  .use(function () {
    this.Compiler = tree => ({ tree })
  } as Plugin<[], HastTree, { tree: HastTree }>)
```

While sanitization comes with added security, adding sanitization causes a lot of extra work to get other features working. Using this caused problems with wiping attributes that needed to be allowed like blurred image urls and class names and causing extra overhead with `#` links. See the [rehype-sanitize docs about dom clobbering](https://github.com/rehypejs/rehype-sanitize#example-headings-dom-clobbering) for more details on the problem with `#` links with user generated content and its workaround.

### Do not sanitize the html

The content pipeline would look the same but without the `rehype-sanitize` plugin. All overhead can be avoided in this case.
